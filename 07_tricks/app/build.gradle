apply plugin: 'android'

archivesBaseName = "demo"

dependencies {
    compile 'com.android.support:support-v4:13.0.0'
    compile project(':library:ActionBarSherlock:library')
    compile project(':library:UnifiedPreference:library')
}

android {
    compileSdkVersion 17
    buildToolsVersion "17.0.0"

    defaultConfig {
        minSdkVersion 8
        targetSdkVersion 17
        versionName '1.0.1'
        packageName = 'com.corner23.android.demo'
    }

    project.ext.appStartupClassName = 'com.corner23.android.demo.MainActivity'
    
    productFlavors {
        rock
        amazonFree {
            packageName = 'com.corner23.android.demo.amazon.free'
        }
        amazonPaid {
            packageName = 'com.corner23.android.demo.amazon.paid'
        }
        playFree {
            packageName = 'com.corner23.android.demo.play.free'
        }
        playPaid {
            packageName = 'com.corner23.android.demo.play.paid'
        }
    }

    signingConfigs {
        release {
            if (project.hasProperty('demoKeyAlias') && 
                project.hasProperty('demoStoreFile') &&
                project.hasProperty('demoStorePassword') &&
                project.hasProperty('demoKeyPassword')) {
                keyAlias = demoKeyAlias
                storeFile = file(demoStoreFile)
                storePassword = demoStorePassword
                keyPassword = demoKeyPassword
            } else {
                signingConfig = null
            }
        }
    }

    buildTypes {
        debug {
            packageNameSuffix ".debug"
            versionNameSuffix "-SNAPSHOT"
        }

        release {
            signingConfig signingConfigs.release

            runProguard true
            proguardFile getDefaultProguardFile('proguard-android.txt')
        }
    }

    // setup your extra resources here, if not defined the default debug and 
    // release sourceSets will be used
    project.ext.amazonPaid = [
        debugRes: ['src/amazonPaidDebug/res'],
        releaseRes: ['src/amazonPaidRelease/res']
    ]

    project.ext.amazonFree = [
        debugRes: ['src/amazonFreeDebug/res'], 
        releaseRes: ['src/amazonFreeRelease/res']
    ]
}

android.applicationVariants.all { variant ->
    variant.mergeResources.doFirst {
        if (project.ext.has(variant.productFlavors.name)) {
            if (project.ext[variant.productFlavors.name].debugRes != null) {
                android.sourceSets.debug.res.srcDirs = project.ext[variant.productFlavors.name].debugRes
            } else {
                android.sourceSets.debug.res.srcDirs = ['src/debug/res']
            }
            
            if (project.ext[variant.productFlavors.name].releaseRes != null) {
                android.sourceSets.release.res.srcDirs = project.ext[variant.productFlavors.name].releaseRes
            } else {
                android.sourceSets.release.res.srcDirs = ['src/release/res']
            }
        } else {
            android.sourceSets.debug.res.srcDirs = ['src/debug/res']
            android.sourceSets.release.res.srcDirs = ['src/release/res']
        }
    }

    // launch after install
    variant.install.doLast {
        def packageSuffix = variant.buildType.packageNameSuffix ? variant.buildType.packageNameSuffix : ""
        def packageName = variant.productFlavors.packageName[0] ? variant.productFlavors.packageName[0] : android.defaultConfig.packageName
        def startupClass = packageName + packageSuffix + '/' + project.ext.appStartupClassName
        def result = exec {
            executable = 'adb'
            args = ['shell', 'am', 'start', '-c', 'android.intent.category.LAUNCHER', '-n', startupClass]
        }
    }

    variant.assemble.doLast {
        rename_and_moveout_apk(variant)
    }
}

def rename_and_moveout_apk(targetVariant) {
    // get hash of current commit
    new ByteArrayOutputStream().withStream { os -> 
        def result = exec {
            executable = 'git'
            args = ['rev-parse', '--short', 'HEAD']
            standardOutput = os
        }
        
        project.ext.gitHash = os.toString().trim();
    }

    // replace output apk name to <product>-<version>-<buildtype>-<githash>.apk
    def versionSuffix = targetVariant.buildType.versionNameSuffix ? targetVariant.buildType.versionNameSuffix : ""
    def versionName = targetVariant.mergedFlavor.versionName + versionSuffix + "-${gitHash}";
    
    if (targetVariant.zipAlign) {
        def apkFinal = targetVariant.outputFile;
        def apkFinalNewName = apkFinal.name.replace(targetVariant.buildType.name, versionName);
        copy {
            from "$apkFinal"
            into "$rootProject.projectDir/out"
            rename ("$apkFinal.name", "$apkFinalNewName")
        }
    }

    def apkProcess = targetVariant.packageApplication.outputFile;
    def apkProcessNewName = apkProcess.name.replace(targetVariant.buildType.name, versionName);
    copy {
        from "$apkProcess"
        into "$rootProject.projectDir/out"
        rename ("$apkProcess.name", "$apkProcessNewName")
    }
}

clean.doLast {
    project.delete "$rootProject.projectDir/out"
}
